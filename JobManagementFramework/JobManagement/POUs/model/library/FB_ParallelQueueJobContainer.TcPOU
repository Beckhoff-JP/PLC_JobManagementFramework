<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.17">
  <POU Name="FB_ParallelQueueJobContainer" Id="{d5fc8dd4-0f17-45e0-b0bb-86aca529f22f}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'enable_dynamic_creation'}
FUNCTION_BLOCK FB_ParallelQueueJobContainer EXTENDS FB_AbstructContainer
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="_append_job" Id="{495b462b-8875-4d61-81d1-98086729a5d3}">
      <Declaration><![CDATA[METHOD PROTECTED _append_job : BOOL
VAR_INPUT
	executor	: I_Job;
END_VAR
VAR
	_deteremine_index :  BOOL;
	_p_executor : POINTER TO FB_Executor;
	future_order_number: INT;
	_parent_future_id: STRING;
	i: 	UDINT := 1;
END_VAR
VAR_INST
	next_index : UDINT := 1;
	last_index : UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set buffer index
IF _num_of_jobs < ParamFuturesLib.MAX_TASK_NUM THEN
	i := next_index;
	_deteremine_index := FALSE;
	REPEAT
		IF i > ParamFuturesLib.MAX_TASK_NUM THEN
			_error_id := -8;
			RETURN;
		ELSIF _executors[i] = 0 THEN
			_deteremine_index := TRUE;
		ELSIF _executors[i].current_state <> E_FutureExecutionState.idle OR
			_executors[i].current_state <> E_FutureExecutionState.finish THEN
			IF NOT _executors[i].persistent_job AND __QUERYPOINTER(_executors[i], _p_executor) THEN
				__DELETE(_p_executor);
			END_IF
			_deteremine_index := TRUE;
		END_IF
		
		IF next_index >= ParamFuturesLib.MAX_TASK_NUM THEN
			next_index := 1;
		ELSE
			next_index := next_index + 1;
		END_IF
		IF NOT _deteremine_index THEN
			i := next_index;
		END_IF
		
	UNTIL
		_deteremine_index
	END_REPEAT

	// Spawn new task with specified future
	_executors[i] := executor;
	
	// Get parent task id
	IF _executor <> 0 THEN
		_executors[i].job_event_observable := _executor.job_event_observable;
		_executors[i].parent_executor := _executor;
		_executors[i].upstream_aborting := _executor.upstream_aborting;
		_parent_future_id := _executor.id;
	END_IF
	
	IF last_index > 0 AND_THEN _executors[last_index] <> 0 THEN
		_executors[last_index].next_job := _executors[i];
		_executors[i].previous_job := _executors[last_index];
		_executors[i].serial := _executors[i].previous_job.serial + 1;
	ELSE
		_executors[i].serial := 1;
	END_IF
	
	last_index := i;
	executor.init();
	
	_num_of_jobs := _num_of_jobs + 1;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="_index_generator_" Id="{0ed4ef36-277f-45bf-bd2d-f3582de94507}">
      <Declaration><![CDATA[(* This is the generator that iteratively generates references to FB_executor instances*)
METHOD _index_generator_ : UINT;
VAR_INPUT
END_VAR
VAR_INST
	_init	: BOOL := FALSE;
	_current_order_number : UINT; // Represent order number of iteration
	_index: UINT;
	_deteremine_index : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT _init THEN
	_current_order_number := 0;
	_index := 1;
	_index_generator_ := 0;
	_init := TRUE;
END_IF

IF _num_of_jobs = 0 THEN
	RETURN;
END_IF


IF _current_order_number >= _num_of_jobs OR _index > ParamFuturesLib.MAX_TASK_NUM THEN
	_init := FALSE;
END_IF

IF _init THEN

	_deteremine_index := FALSE;
	REPEAT
		IF _index > ParamFuturesLib.MAX_TASK_NUM THEN
			_index_generator_ := 0;
			RETURN;
		ELSIF _executors[_index] = 0 THEN
			_index := _index + 1;
		ELSIF _executors[_index].current_state = E_FutureExecutionState.finish THEN
			IF _executors[_index].transition THEN
				_num_of_jobs := _num_of_jobs - 1;
				_deteremine_index := TRUE;
			ELSE
				_index := _index + 1;
			END_IF
		ELSE
			_deteremine_index := TRUE;
		END_IF
	UNTIL
		_deteremine_index
	END_REPEAT

	IF _executors[_index] <> 0 THEN
		_index_generator_ := _index;
	ELSE
		_index_generator_ := 0;
	END_IF
	_current_order_number := _current_order_number + 1;
	_index := _index + 1;
ELSE
	_index_generator_ := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="abort" Id="{a4220ea8-4c54-4bea-912f-7dce6f7f9a5d}">
      <Declaration><![CDATA[METHOD abort : BOOL // Return TRUE if finish.
VAR
	_all_done : BOOL;
END_VAR
VAR_INST
	_executor : I_Job;
	await : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_all_done := TRUE;
REPEAT
	_executor := each_executor;
	IF _executor <> 0 THEN
		await := _executor.abort();
		IF _executor.busy OR NOT await THEN
			_all_done := FALSE;
		END_IF
	END_IF
UNTIL
	_executor = 0
END_REPEAT
abort := _all_done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="execute" Id="{13492bc8-de83-46e7-84c1-08243ad582cc}">
      <Declaration><![CDATA[METHOD execute : BOOL // Return TRUE if finish.
VAR
	_head : BOOL;
	_future_id :UINT;
	i: UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[execute := FALSE;

IF _num_of_jobs = 0 THEN
	RETURN;
END_IF

REPEAT
	// キューインされたFB_executorインスタンスを順に取り出すイテレータ。_endがTRUEになれば全て取り出し完了。_headは先頭のみtrueになる。
	i := _index_generator_();
	IF i > 0 THEN
		IF _executors[i].execute() THEN
			_executors[i].reset(FALSE);
			execute := _num_of_jobs = 0 AND NOT _continuous_mode;
		ELSE
			CASE _executors[i].current_state OF
				E_FutureExecutionState.idle:
					_executors[i].init();
				E_FutureExecutionState.wait_for_process:
					IF _executor.ready AND SUPER^._auto_start THEN
						_executors[i].start();
					END_IF
	
				//E_FutureExecutionState.init, E_FutureExecutionState.process, E_FutureExecutionState.quit:
				//	IF 	_executors[i].current_state = E_FutureExecutionState.process THEN
				//		// Report total futures
				//		current_executing_future := _executors[i].future;						
				//	END_IF
			END_CASE
			_error_id := _executors[i].nErrorID;
		END_IF
	END_IF
UNTIL
	i = 0
END_REPEAT
]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{8aeab0c6-d12b-4b5a-acab-44e82acbfd1b}">
      <Declaration><![CDATA[METHOD init : BOOL // Return TRUE if finish.
VAR
	_executor : I_Job;
	_init_done : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_init_done := TRUE;
REPEAT
	_executor := each_executor;
	IF _executor <> 0 THEN
		_executor.job_event_observable := THIS^._executor.job_event_observable;
		IF NOT _executor.init() THEN
			_init_done := FALSE;
		END_IF
	END_IF
UNTIL
	_executor = 0
END_REPEAT

_error_id := 0;
init := _init_done;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>